using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class Node
{
    /// <summary>
    /// 노드 생성자
    /// </summary>
    /// <param name="_isWall"> 현재 벽인지 판별 </param>
    /// <param name="x"> 노드의 x 포지션 </param>
    /// <param name="y"> 노드의 y 포지션 </param>
    public Node(bool _isWall, int x, int y)
    {
        isWall = _isWall;

        xPos = x;

        yPos = y;
    }

    [Tooltip("현재 노드가 벽인지 판별")]
    public bool isWall;

    [Tooltip("현재 노드의 부모 노드(이전 노드)")]
    public Node ParentNode;

    [Tooltip("현재 노드의 X 포지션")]
    public int xPos;

    [Tooltip("현재 노드의 Y 포지션")]
    public int yPos;

    [Tooltip("시작으로부터 이동한 거리")]
    public int g;

    [Tooltip("장애물을 무시한 목표까지의 거리 (가로, 세로)")]
    public int h;

    public int f //g + h
    {
        get
        {
            return g + h;
        }
    }
}
public class BasicEnemy : MonoBehaviour
{
    [Tooltip("현재 감지한 플레이어 오브젝트")]
    private GameObject detectedPObj;

    #region 이동 관련 요소들 모음
    [Header("이동 관련 요소들 모음")]

    [Tooltip("추격 후 플레이어 감지 범위")]
    private const int updateDetectedRange = 50;

    [Tooltip("현재 노드가 벽인지 판별")]
    private bool isWall;

    [Tooltip("경로 탐색 시 시작 포지션")]
    private Vector2 startPos;

    [Tooltip("최종 경로 노드 리스트")]
    public List<Node> finalNodeList;

    [Tooltip("전체 경로 범위 노드 배열")]
    private Node[,] nodeArray = new Node[updateDetectedRange * 2 + 1, updateDetectedRange * 2 + 1];

    [Tooltip("경로 시작 노드")]
    private Node startNode;

    [Tooltip("목적지 노드")]
    private Node targetNode;

    [Tooltip("현재 경로 노드")]
    private Node curNode;

    [Tooltip("경로 탐색 가능한 노드 리스트")]
    private List<Node> openList = new List<Node>();

    [Tooltip("경로 탐색 완료한 노드 리스트")]
    private List<Node> closedList = new List<Node>();
    #endregion

    /// <summary>
    /// 플레이어 감지 시작
    /// </summary>
    public virtual void DetectedPlayer(GameObject detectedPlayerObj)
    {
        if (detectedPObj != null)
        {
            return;
        }

        detectedPObj = detectedPlayerObj;

        PathFinding(detectedPlayerObj.transform.position);
    }

    /// <summary>
    /// 경로 탐색 함수
    /// </summary>
    public void PathFinding(Vector2 targetPos)
    {
        startPos = new Vector2(transform.position.x, transform.position.y);

        for (int i = -updateDetectedRange; i <= updateDetectedRange; i++) //플레이어 추격 범위만큼 노드 세팅
        {
            for (int j = -updateDetectedRange; j <= updateDetectedRange; j++)
            {
                isWall = false;

                foreach (Collider2D collider in Physics2D.OverlapCircleAll(new Vector2(startPos.x + i, startPos.y + j), 0.40f))
                {
                    if (collider.gameObject.CompareTag("Wall"))
                    {
                        isWall = true;
                    }
                }

                nodeArray[i + updateDetectedRange, j + updateDetectedRange] = new Node(isWall, (int)startPos.x + i, (int)startPos.y + j);
            }
        }

        startNode = nodeArray[updateDetectedRange, updateDetectedRange];

        targetNode = nodeArray[(int)targetPos.x - (int)startPos.x + updateDetectedRange, (int)targetPos.y - (int)startPos.y + updateDetectedRange];

        closedList.Clear();

        finalNodeList.Clear();

        openList.Clear();

        openList.Add(startNode);

        while (openList.Count > 0)
        {
            // 오픈리스트 중 가장 f가 작은 것, f가 같다면 h가 작은 것, h도 같다면 0번째 것을 현재노드로 하고 열린리스트에서 닫힌리스트로 옮기기
            curNode = openList[0];

            openList.Remove(curNode);
            closedList.Add(curNode);

            for (int i = 0; i < openList.Count; i++)
            {
                if (openList[i].f <= curNode.f && openList[i].h < curNode.h)
                {
                    curNode = openList[i];
                }
            }

            // 마지막
            if (curNode == targetNode)
            {
                Node TargetCurNode = targetNode;

                while (TargetCurNode != startNode)
                {
                    finalNodeList.Add(TargetCurNode);
                    TargetCurNode = TargetCurNode.ParentNode;
                }

                finalNodeList.Add(startNode);
                finalNodeList.Reverse();

                //for (int i = 0; i < finalNodeList.Count; i++)
                //{
                //    print(i + "번째는 " + finalNodeList[i].xPos + ", " + finalNodeList[i].yPos);
                //}

                StartCoroutine(Move());

                return;
            }

            // ↑ → ↓ ←
            OpenListAdd(curNode.xPos, curNode.yPos + 1);
            OpenListAdd(curNode.xPos + 1, curNode.yPos);
            OpenListAdd(curNode.xPos, curNode.yPos - 1);
            OpenListAdd(curNode.xPos - 1, curNode.yPos);
        }
    }

    /// <summary>
    /// 진행 가능한 경로의 노드들 오픈리스트 추가 함수
    /// </summary>
    /// <param name="checkX"></param>
    /// <param name="checkY"></param>
    private void OpenListAdd(int checkX, int checkY)
    {
        //감지 범위를 벗어나지 않고, 벽이 아니면서, 닫힌리스트에 없다면
        if (checkX >= startPos.x - updateDetectedRange && checkX <= startPos.x + updateDetectedRange
            && checkY >= startPos.y - updateDetectedRange && checkY <= startPos.y + updateDetectedRange
            && nodeArray[(int)(checkX - startPos.x) + updateDetectedRange, (int)(checkY - startPos.y) + updateDetectedRange].isWall == false
            && closedList.Contains(nodeArray[(int)(checkX - startPos.x) + updateDetectedRange, (int)(checkY - startPos.y) + updateDetectedRange]) == false)
        {
            // 이웃노드에 넣기
            Node neighborNode = nodeArray[(int)(checkX - startPos.x) + updateDetectedRange, (int)(checkY - startPos.y) + updateDetectedRange];
            int moveCost = 10;

            // 이동비용이 이웃노드 g보다 작거나 또는 열린리스트에 이웃노드가 없다면 g, h, ParentNode를 설정 후 열린리스트에 추가
            if (moveCost < neighborNode.g || openList.Contains(neighborNode) == false)
            {
                neighborNode.g = moveCost;
                neighborNode.h = (Mathf.Abs(neighborNode.xPos - targetNode.xPos) + Mathf.Abs(neighborNode.yPos - targetNode.yPos)) * 10;
                neighborNode.ParentNode = curNode;

                openList.Add(neighborNode);
            }
        }
    }

    /// <summary>
    /// 움직임 함수
    /// </summary>
    /// <param name="curMoveState"> 현재 이동 목표 상태 </param>
    /// <returns></returns>
    public IEnumerator Move() //MoveState curMoveState
    {
        //moveVector = Vector3.zero;

        //if (curMoveState == MoveState.Up || curMoveState == MoveState.Down)
        //{
        //    moveVector.y = (curMoveState == MoveState.Up) ? 1f : -1f;
        //}
        //else
        //{
        //    moveVector.x = (curMoveState == MoveState.Right) ? 1f : -1f;
        //}

        //while (true)
        //{
        //    transform.position += moveVector * Time.deltaTime * speed;

        //    if (curMoveState == MoveState.Up || curMoveState == MoveState.Down)
        //    {
        //        moveTargetPos.y = Mathf.FloorToInt(transform.position.y);
        //    }
        //    else
        //    {
        //        moveTargetPos.x = Mathf.FloorToInt(transform.position.x);
        //    }

        //    if (!Input.GetMouseButton(0) || isChangeDir)
        //    {
        //        endPos = transform.position + moveVector;

        //        if (curMoveState == MoveState.Up || curMoveState == MoveState.Down)
        //        {
        //            endPos.y = Mathf.FloorToInt(endPos.y);

        //            if (curMoveState == MoveState.Down)
        //            {
        //                endPos.y += 1;
        //            }
        //        }
        //        else
        //        {
        //            endPos.x = Mathf.FloorToInt(endPos.x);

        //            if (curMoveState == MoveState.Left)
        //            {
        //                endPos.x += 1;
        //            }
        //        }

        //        while ((curMoveState == MoveState.Up && transform.position.y <= endPos.y) ||
        //               (curMoveState == MoveState.Down && transform.position.y >= endPos.y) ||
        //               (curMoveState == MoveState.Right && transform.position.x <= endPos.x) ||
        //               (curMoveState == MoveState.Left && transform.position.x >= endPos.x))
        //        {
        //            transform.position += moveVector * Time.deltaTime * speed;

        //            yield return null;
        //        }

        //        transform.position = endPos;

        //        if (isChangeDir)
        //        {
        //            StartCoroutine(Move(changePressState));
        //        }
        //        else
        //        {
        //            curState = CurState.Idle;
        //        }

        //        yield break;
        //    }

        //    yield return null;
        //}

        //curMousePos = mainCam.ScreenToWorldPoint(Input.mousePosition);

        //if (curMousePos.x > -8f && curMousePos.x > -9.8f)
        //{

        //}
        //while (true)
        //{
        //    //RaycastHit2D hit = Physics2D.Raycast()
        //}
        yield return null;
    }

    void OnDrawGizmos()
    {
        if (finalNodeList.Count != 0)
        {
            for (int i = 0; i < finalNodeList.Count - 1; i++)
            {
                Gizmos.DrawLine(new Vector2(finalNodeList[i].xPos, finalNodeList[i].yPos), new Vector2(finalNodeList[i + 1].xPos, finalNodeList[i + 1].yPos));
            }
        }
    }
}
